<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Leaf"><title>Golang study - 01 · Leaf</title><meta name="description" content="编译Go：12345go buildgo build -0 &amp;quot;xx.exe&amp;quot; windows下.exego run main.go 执行main.go文件go install 两步，先编译后拷贝 

基本语法12345678910111213141516package maini"><meta name="keywords" content="Blog"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 5.0.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Leaf</a></h3><div class="description"><p>一片叶子.<br />Leaf On The Road.</p></div></div></div><ul class="social-links"><li><a href="https://github.com/leafon/leafon.github.io"><i class="fa fa-github"></i></a></li><li><a href="516037580@qq.com"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="http://sighttp.qq.com/authd?IDKEY="><i class="fa fa-qq"></i></a></li><li><a href="https://github.com/leafon/leafon.github.io"><i class="fa fa-mortar-board"></i></a></li></ul><div class="footer"><div class="p"> <span>© 2020 </span><i class="fa fa-star"></i><span> Leaf</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><a href="https://github.com/mrcore/hexo-theme-Anatole-Core" target="_blank">Anatole-Core.  </a><a href="http://www.beian.miit.gov.cn/" target="_blank">&nbsp;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li><li><a href="/tags">标签</a></li><li><a href="/about">关于</a></li><li><a href="/guestbook">留言</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Golang study - 01</a></h3></div><div class="post-content"><h2 id="编译Go："><a href="#编译Go：" class="headerlink" title="编译Go："></a>编译Go：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">go build</span><br><span class="line">go build -0 <span class="string">&quot;xx.exe&quot;</span> windows下.exe</span><br><span class="line"></span><br><span class="line">go run main.go 执行main.go文件</span><br><span class="line">go install 两步，先编译后拷贝 </span><br></pre></td></tr></table></figure>

<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import <span class="string">&quot;fmt&quot;</span></span><br><span class="line">//全局变量,以关键字开头 1-var 2-const</span><br><span class="line">var name string</span><br><span class="line">var age int</span><br><span class="line">//<span class="string">&quot;&quot;</span>字符串 很不一样 <span class="string">&#x27;&#x27;</span>字符</span><br><span class="line">var ss = <span class="string">&quot;类型推断&quot;</span></span><br><span class="line">const(</span><br><span class="line">    PI = 3.141592653</span><br><span class="line">)</span><br><span class="line">//main入口函数，没有参数，没有返回值</span><br><span class="line">func <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">    leaf := <span class="string">&#x27;局部声明变量,必须使用，函数内声明&#x27;</span></span><br><span class="line">    _, hh = <span class="string">&quot;匿名变量，不使用&quot;</span>,<span class="string">&#x27;H&#x27;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;print le&quot;</span>, leaf)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>iota枚举<br>1.在const关键字出现时被重置为0<br>2.const中每新增一行增加1</p>
<h2 id="流程控制-if"><a href="#流程控制-if" class="headerlink" title="流程控制 if"></a>流程控制 if</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var age = 19</span><br><span class="line"><span class="keyword">if</span> age &gt; 18 &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;今年上学不开学，家里蹲！&quot;</span>)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;小朋友，你是不是有很多的问好？&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := 0; i &lt; 10 ; i++ &#123;</span><br><span class="line">    // i作用域区域</span><br><span class="line">&#125;</span><br><span class="line">var i = 0</span><br><span class="line"><span class="keyword">for</span> ; i &lt; 10 ; i++ &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var str = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="keyword">for</span> i, v := range s &#123;</span><br><span class="line">    fmt.Println(i, v)</span><br><span class="line">    // %d索引，10 %c字符 %T类型</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d %c\n&quot;</span>, i, v)</span><br><span class="line">&#125;</span><br><span class="line">// _哑元变量</span><br><span class="line"><span class="keyword">for</span> _, v := range s &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%c\n&quot;</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串、字符、字节"><a href="#字符串、字符、字节" class="headerlink" title="字符串、字符、字节"></a>字符串、字符、字节</h2><p>“” 双引号字符串 UTF8编码，一般一个汉字 = 3字节<br>‘’ 单引号自符，单个字母、单个富豪、单个文字<br>字节： 1byte = 8bit</p>
<hr>
<h2 id="study-02"><a href="#study-02" class="headerlink" title="study - 02"></a>study - 02</h2><h2 id="数组、切片"><a href="#数组、切片" class="headerlink" title="数组、切片"></a>数组、切片</h2><p>var arr []int<br>var arr [10]int<br>var arr []bool<br>var arr […]int{1,2,3,4,5}<br>arr := arr[0:4]切片，[0,4)<br>al := arr[:4] === [0:4]<br>al := arr[3:] === [3:len(arr)]<br>al := arr[:] === [0:len(arr)]<br>cap(al) //切片容量：从第一个裁切元素到原数组到最后的数量<br>arr[3] = 1333元素组改变，切片元素引用的地址，值和arr一样<br>for i := 0, i &lt; len(arr); i++ {<br>    fmt.println(arr[i])<br>}<br>for i, v := range arr {<br>    fmt.Println(“%d %c”,i ,v)<br>}</p>
<h2 id="make-函数切片"><a href="#make-函数切片" class="headerlink" title="make()函数切片"></a>make()函数切片</h2><p>func main(){<br>    ss := make([]int, 5,10)<br>    fmt.Println(“ss=%v len(ss)=%d”, ss, len(ss))<br>    //len(ss) = 5 cap(ss) = 10<br>    //切片的本质就是一个框，框住了一块连续的内存，属于引用类型，数据保存在底层数组里<br>    //长度判断 len(ss) == 0<br>    //切片便利<br>    for i := 0;i&lt; len(ss); i++{<br>        fmt.Println(ss[i])<br>    }<br>    for i ;v := range ss{<br>        fmt.Println(i ,v)<br>    }<br>}</p>
<h2 id="append-copy"><a href="#append-copy" class="headerlink" title="append copy"></a>append copy</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ss := []string(<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>,<span class="string">&quot;cc&quot;</span>)</span><br><span class="line">ss[3] = <span class="string">&quot;dd&quot;</span> //报错，没有这个元素，索引越界 index out of range</span><br><span class="line">// len(ss) = 3 <span class="built_in">cap</span>(ss) = 3</span><br><span class="line">ss = append(ss, <span class="string">&quot;dd&quot;</span>)//为切片增加元素，原来切片接收返回【重新创建一个底层数组】</span><br><span class="line">ss = append(ss, <span class="string">&quot;dd&quot;</span>, <span class="string">&quot;ee&quot;</span>)</span><br><span class="line">// len(ss) = 4 <span class="built_in">cap</span>(ss) = 6 --append之后容量变了</span><br><span class="line"></span><br><span class="line">var a1 := [3]init&#123;1,3,5&#125;</span><br><span class="line">var a3 := make([]init, 3, 3)</span><br><span class="line">copy(a3,a1)</span><br><span class="line">a1[0] = 100</span><br><span class="line">a3不变</span><br></pre></td></tr></table></figure>

<p>new 和 make 区别<br>make都是用来申请内存<br>new少用，一般给基本数据类型申请内存<br>make用来给slice map chan申请内存，make函数返回的对应的三个类型本身</p>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var ms map[string]int //没有初始化，内存中没有空间 ms == nil XX </span><br><span class="line">ms = make(map[string]int, 10) //初始化map容量</span><br><span class="line">ms[<span class="string">&quot;haha&quot;</span>] = 18</span><br><span class="line">ms[<span class="string">&quot;wawa&quot;</span>] = 20</span><br><span class="line">v, ok := mm[<span class="string">&quot;v&quot;</span>] ==&gt;默认ok==0</span><br><span class="line">map遍历</span><br><span class="line"><span class="keyword">for</span> K, v := range ms &#123;</span><br><span class="line">    fmt.Println(k, v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, v := range ms &#123;</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Go语言并发模型"><a href="#Go语言并发模型" class="headerlink" title="Go语言并发模型"></a>Go语言并发模型</h2><p> 不要通过共享内存来通信，而要通过通信来实现内存共享–Go的并发哲学，依赖CSP模型，基于channel实现。<br> 进程、线程、协程<br> G语言中支撑整个scheduler实现的四个重要结构，分别是M\G\P\Sched，前三个定义在runtime.h中，Sched定义在proc.c中<br> Sched结构就是调度器，它维护有存储M和G的队列以及调度器的一些状态信息<br> M结构式Machine，系统线程，由操作系统管理，goroutine就是跑在M上的<br> P结构式Processor处理器，执行goroutine，维护一个goroutine队列，即runqueue。Processor是让我们从N：1到M：N调度的重要部分<br> G是goroutine实现的核心结构，包含了栈，指令指针，以及其他队调度goroutine很重的信息，例如其阻塞的channel</p>
<h2 id="channel-通道"><a href="#channel-通道" class="headerlink" title="channel 通道"></a>channel 通道</h2><p>: goroutine之间的通道，可以让goroutine之间相互通信。nil通道不能使用<br> var 通道名 chan 数据类型<br> var a chan int<br> fmt.Println(“%t,%v\n”,a,a)//类型，值</p>
<h3 id="发送和接收，读写数据都是阻塞式的"><a href="#发送和接收，读写数据都是阻塞式的" class="headerlink" title="发送和接收，读写数据都是阻塞式的"></a>发送和接收，读写数据都是阻塞式的</h3><p> 写入数据chan &lt;- data<br> 读取数据data &lt;- chan<br> channel是同步的，同一时间只有一条goroutine使用<br> `死锁：只有读取／只有写入<br>  var cha1 chan boll<br>  cha1 = make(chan boll)</p>
<p>  go func(){<br>      for i := 0;i&lt;10;i++{<br>         fmt.Println(“子goroutine中，i: “,i)<br>      }<br>      //写入数据<br>      cha1 &lt;- true<br>    }()<br>    //读取数据<br>    data := &lt;-cha1 //没有数据会阻塞</p>
<h2 id="关闭通道"><a href="#关闭通道" class="headerlink" title="关闭通道"></a>关闭通道</h2><p>close(ch)<br>检测通道是否已经关闭：<br>v, ok := &lt;- ch ok来判断是否关闭</p>
<p> for - range,访问通道数据</p>
<p>ch1 := make(chan int)<br>go sendData(ch1)<br>for v := range ch1{<br> fmt.Println(v)<br>}</p>
<p>func sendData(ch1 chan int){<br>    for i := 0;i&lt;10;i++{<br>        time.Sleep(1*time.Second)<br>        ch1 &lt;- i<br>    }<br>    close(ch1)//通知关闭通道<br>}</p>
<h2 id="缓冲通道"><a href="#缓冲通道" class="headerlink" title="缓冲通道"></a>缓冲通道</h2><p>ch := make(chan type,capacity)<br>非缓冲： ch := make(chan T)<br>缓冲： make(chan T, 5) 创建多余容量，先进先出<br>发送接收-缓冲区满了才会阻塞 – 有多余容量就不会阻塞<br>== len(ch) cap(ch)<br>ch2 := make(chan int,5)<br>ch2 &lt;- 100<br>ch2 &lt;- 200<br>ch2 &lt;- 300<br>ch2 &lt;- 400<br>ch2 &lt;- 500</p>
<h2 id="定向通道"><a href="#定向通道" class="headerlink" title="定向通道"></a>定向通道</h2><p>能发送接收数据-双向通道<br> ch &lt;- data –写入数据<br> data := &lt;- chan –读取数据<br>只能发送or读取-单向通道<br> ch := make(chan &lt;- init) –只能写<br> ch := make(&lt;- chan init) –只能读</p>
<p>func fun(ch chan &lt;- init){<br> //函数内部只能写入数据，外面无意义<br>}<br>func fun(ch &lt;- chan init){<br> //函数内部只能读取数据，外面无意义<br>}</p>
<h2 id="time包"><a href="#time包" class="headerlink" title="time包"></a>time包</h2><p> Timer一次性的时间触发<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">timer := time.NewTimer(3*time.Second)//计时器</span><br><span class="line">//当前时间 time.Now()</span><br><span class="line">ch := timer.C</span><br><span class="line">&lt;-ch //读取ch</span><br></pre></td></tr></table></figure><br>  Timer.Stop()<br>  Timer.After() === NewTimer(d).C –返回一个chan，存储之前的时间<br>  ch := time.After(3*time.Second)</p>
<h2 id="select语句"><a href="#select语句" class="headerlink" title="select语句"></a>select语句</h2><p>控制语句，随机选择一个case执行【多个case情况下】，没有case &amp; default将被阻塞<br> 每个case都是一个通道</p>
<p>ch1 := make(chan int)<br>ch2 := make(chan int)<br>ch3 := make(chan int) //没有写入数据，会阻塞<br>go func (){<br>    time.Sleep(3*time.Second)<br>    ch1 &lt;- 100<br>}<br>go func(){<br>    ch2 &lt;- 200<br>}<br>select{<br>    case &lt;- ch3:<br>        fmt.Println(“阻塞了”)<br>    case num1 := &lt;-ch1:<br>        fmt.Println(‘ch1 = ‘, num1)<br>    case num2, ok:= &lt;-ch2<br>        if ok{<br>            fmt.Print(‘ch2 = ‘, num2)<br>        }else{<br>            fmt.Print(‘ch2 = ‘, num2)<br>        }<br>    default:<br>        fmt.Println(‘default’)<br>}</p>
<h2 id="reflect"><a href="#reflect" class="headerlink" title="reflect"></a>reflect</h2><p>reflect.TypeOf(x)<br>reflect.ValyeOf(x)</p>
<p>v := reflect.ValueOf(x)<br>v.Kind() == reflect.Float64<br>v.Type()<br>v.Float()</p>
<h2 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h2><h2 id="Web-APIs-和-JS基础关联"><a href="#Web-APIs-和-JS基础关联" class="headerlink" title="Web APIs 和 JS基础关联"></a>Web APIs 和 JS基础关联</h2><p>js基础阶段<br>ECMAScript标准规定的基本语法<br>Web APIs阶段<br>webApis是W3C组织的标准<br>主要学习DOM和BOM<br>web APIs是JS独有的部分<br>JS基础学习ECMAScript基础语法为后面做铺垫，Web APIs是JS的应用，大量使用JS基础语法做交互效果</p>
<h2 id="API-Application-Programming-Interface"><a href="#API-Application-Programming-Interface" class="headerlink" title="API(Application Programming Interface)"></a>API(Application Programming Interface)</h2><p>应用程序编程接口</p>
<h2 id="Web-API"><a href="#Web-API" class="headerlink" title="Web API"></a>Web API</h2><p>浏览器提供的一套操作浏览器功能和页面元素的API（DOM &amp; BOM）</p>
<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>文档对象模型 (Document Object Model)</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-08-03</span><i class="fa fa-tag"></i><span class="leancloud_visitors"></span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,https://github.com/leafon/leafon.github.io/2020/08/03/Go/,Leaf,Golang study - 01,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2020/08/18/nodejs/" title="">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2020/07/31/hexo/" title="hexo install">下一篇</a></li></ul></div><script src="/js/visitors.js"></script><a id="comments"></a><div id="vcomments" style="margin:0 30px;"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/gh/xcss/valine@latest/dist/Valine.min.js"></script><script>var valine = new Valine({
  el:'#vcomments',
  notify:false || false, 
  verify:false|| false, 
  app_id:'',
  app_key:'',
  placeholder:'命途多舛、痴迷淡然...',
  path: window.location.pathname,
  serverURLs: '',
  visitor:true,
  recordIP:true,
  avatar:'mp'
})</script></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script src="/js/baidu-tongji.js"></script></body></html>